<!doctype s-function-doc system "s-function-doc.dtd" [
<!entity % S-OLD "INCLUDE">
]
>
<s-function-doc>
<s-topics>
   <s-topic>residuals.coxph</s-topic>
</s-topics>
<s-title>
Calculate Residuals for a Cox Regression 
</s-title>
<s-description>
Calculates martingale, deviance, score or Schoenfeld residuals for a 
Cox proportional hazards model. 
</s-description>
<s-usage>
<s-old-style-usage>
residuals.coxph(object, type="martingale", collapse=F, weighted=F) 
</s-old-style-usage>
</s-usage>
<s-args-required>
<s-arg name="object">
an object inheriting from class <s-expression>coxph</s-expression>, representing a fitted Cox 
regression model. 
Typically this is the output from the <s-expression>coxph</s-expression> function. 
</s-arg>
</s-args-required>
<s-args-optional>
<s-arg name="type">
character string indicating the type of residual desired. 
Possible values are <s-expression>"martingale"</s-expression>, <s-expression>"deviance"</s-expression>, <s-expression>"score"</s-expression>, <s-expression>"schoenfeld"</s-expression>, 
"dfbeta", <s-expression>"dfbetas"</s-expression>, and <s-expression>"scaledsch"</s-expression>. 
Only enough of the string to determine a unique match is required. 
</s-arg>
<s-arg name="collapse">
vector indicating which rows to collapse (sum) over. 
In time-dependent models more than one row data can pertain 
to a single individual. 
If there were 4 individuals represented by 3, 1, 2 and 4 rows of data 
respectively, then <s-expression>collapse=c(1,1,1, 2, 3,3, 4,4,4,4)</s-expression> could be used to 
obtain per subject rather than per observation residuals. 
if <s-expression>TRUE</s-expression> and the model was fit with case weights, then the weighted 
residuals are returned. 
</s-arg>
</s-args-optional>
<s-value>
For martingale and deviance residuals, the returned object is a vector 
with one element for each subject (without <s-expression>collapse</s-expression>). 
For score residuals it is a matrix 
with one row per subject and one column per variable. 
The row order will match the input data for the original fit. 
For Schoenfeld residuals, the returned object is a matrix with one row 
for each event and one column per variable.  The rows are ordered by time 
within strata, and an attribute <s-expression>strata</s-expression> is attached that contains the 
number of observations in each strata. 
The scaled Schoenfeld residuals are used in the <s-expression>cox.zph</s-expression> function. 
<br><br>
The score residuals are each individual's contribution to the score vector. 
Two transformations of this are often more useful: 
<s-expression>dfbeta</s-expression> is the approximate change in the 
coefficient vector if that observation were dropped, 
and <s-expression>dfbetas</s-expression> is the approximate change in the coefficients, scaled by 
the standard error for the coefficients. 
</s-value>
<s-section name=" NOTE">

For deviance residuals, the status variable may need to be reconstructed. 
For score and Schoenfeld residuals, the X matrix will need to be reconstructed. 
</s-section>
<s-section name=" REFERENCES">

Therneau, T., Grambsch, P., and Fleming. T. (1990). 
Martingale based residuals for survival models. 
<it>Biometrika</it>
<bf>77</bf>, 147-160. 
</s-section>
<s-see>
<s-function name="coxph.sgm">coxph</s-function>. </s-see>
<s-examples>
<s-example type = text>
fit &lt;- coxph(Surv(start, stop, event) ~ (age + surgery) * transplant, 
             data=heart) 
mresid &lt;- resid(fit, collapse=heart$id) 
</s-example>
</s-examples>
<s-keywords>
<s-keyword>survival4</s-keyword>
</s-keywords>
<s-docclass>
function
</s-docclass>
</s-function-doc>
