    
\subsection{coxvarMlist}
In a mixed-effects model the random effects $b$ are assumed to
follow a Gaussian distribution
$$
  b \sim N(0, \Sigma)
$$
In all the random effects modeling programs that I am aware of,
the user specifies the structure of $\Sigma$ and the program
constructs the actual matrix.  
For instance, `independent', `compound symmetry', or `autoregressive'.
This basic approach does not work for genetic studies, since the
correlation is based on family structure and cannot be inferred from
a simple keyword.
The [[coxvarMlist]] variance specification accepts a list of
fixed matrices $A_1$, $A_2$, ... and fits the variance
structure $\Sigma = \sigma_1^2 A_1 + \sigma_2^2 A_2 + \ldots$.
The individual matrices are often in a block-diagonal sparse 
representation due to size.
(The motivating study for this structure had 26050 subjects with a
random intercept per subject, so that $A$ was 26050 by 26050.)

The matrices must have dimnames that match the levels of the 
grouping variable.  Much of the initialization work is to verify
this, remove unneeded columns of the matrices (if for instance a
subject has been dropped due to missing values), and reorder the
grouping variable to match the resulting matrix. ( Sparse matrices
cannot be arbitrarily reordered, so whatever label is on row 1 of the
variance matrix needs to become the first level of the grouping
variable, the second row the second, etc, during the computations.)
Much of this low level work is done by the [[coxme.varcheck]] routine.

Three checks on the matrices are commonly added.  
\begin{enumerate}
\item A solution with $A^*= A/2$ and $\sigma^* = \sigma \sqrt{2}$ is
of course equivalent to one with $A$ and $\sigma$.
For uniqueness, the matrices $A_1$, $A_2$ etc are rescaled to have a
diagonal of 1.  Kinship matrices in particular have a diagonal of 1/2.
\item The individual $A$ matrices are checked to verify that each is
positive definite.  If they are not this is most often reflects an 
error in forming them.
\item The parameters $\sigma$ are constrained to be $>0$.
\end{enumerate}
%I have had one problem where the first two had to be relaxed: to understand
%the interaction of gender and inheritance in breast/prostate cancer,
%we wanted to fit a model with the $n$ by $n$ kinship matrix $K$ as the
% correlation, but
%with separate scaling factors for male/male, male/female, and female/female
%pairs of subjects.
%This is easily done by a separation $K = K_{mm} + K_{ff} + K_{mf}$,
%where the $K_{mm}$ matrix for instance has zeros for all male/female and
%female/female elements.
%The $K_{mf}$ matrix has zero on the diagonal, so cannot be rescaled nor is
%it positive definite.

<<coxvarMlist>>=
coxvarMlist <- function(..., rescale=TRUE, pdcheck=TRUE,  positive=NULL) {
    varlist <- list(...)
    # Because of environments, the init function will inherit the
    #  three variables below
    rescale <- rescale
    pdcheck <- pdcheck
    positive <- positive
    
    initialize <- function(initial, fixed, intercept, G, Z, sparse) {
        ncluster <- length(G)
        if (ncluster==0) stop ("Mlist variance requires a grouping variable")
        if (length(Z)>0) stop ("Mlist variance does not allow random slopes")
        if (!intercept)  stop ("Mlist variance applies only to intercepts")

        groups <- expand.nested(G)

        if (length(varlist)==1) varlist <- varlist[[1]] #unlist singletons
        temp <- coxme.varcheck(ncluster, varlist, n=length(G[[1]]),
                               gvars= names(G), 
                               groups= groups[[ncluster]], sparse,
                               rescale, pdcheck)
        ntheta <- temp$ntheta
        theta <- seq(.2, .3, length=ntheta) 
        if (length(initial)>0) {
            if (length(initial) != ntheta) 
                return(list(error="Wrong length for initial vector"))
            theta <- initial
            }
        if (length(fixed) >0) {
            if (length(fixed) != ntheta)
                return(list(error="Wrong length for fixed values"))
            which.fixed <- (!(is.na(fixed) | fixed==0))
            }
        else which.fixed <- rep(FALSE, ntheta)

        if (is.null(positive)) positive <- rep(TRUE, ntheta)
        else {
            if (!is.logical(positive))
                return(list(
                       error="Positivity constraint must be a logical vector"))
            if (length(positive) != ntheta) 
                return(list(error="Wrong length for positivity constraint"))
            }
        if (any(positive & theta <=0))
            return(list(error="Invalid initial value, must be positive"))        
        theta[positive] <- log(theta[positive])

        list(F=temp$kindex, X=NULL, theta=theta[!which.fixed],
             parms=list(varlist =temp$varlist[[1]], theta=theta,
                        fixed=which.fixed, positive=positive))
        }
    
     generate <- function(newtheta, parms) {
         theta <- parms$theta
         theta[!parms$fixed] <- newtheta
         theta[parms$positive] <- exp(theta[parms$positive])
         
         varmat <- parms$varlist[[1]] * theta[1]
         if (length(theta) >1) {
             for (i in 2:length(theta)) {
                 varmat <- varmat + theta[i]*parms$varlist[[i]]
                 }
             }
         varmat
         }

    wrapup <- function(newtheta,parms) {
        theta <- parms$theta
        theta[!parms$fixed] <- newtheta
        theta[parms$positive] <- exp(theta[parms$positive])
        theta
        }
    
    out <- list(initialize=initialize, generate=generate, wrapup=wrapup)
    oldClass(out) <- 'coxvar'
    out
    }
@ 
